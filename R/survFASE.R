#' Survival analysis using metafeatures
#'
#' @description survFASE finds survival rate of patients using altenative splicing data. It requires exon, intron and junction expression of the samples generated using FASE (check \code{\link{EPrnaseq}}, \code{\link{iPrnaseq}} and \code{\link{DEJ}}). rownames of all expression files and clinical data should have the same identifier/sample ID, otherwise survFASE would not be able to perform survival analysis. survFASE uses RMM/iMM to find metafeature(s) associated with the given exonID/intronID and incorporate the expression of those metafeatures with respective exonID/intronID.
#'
#' @param Time survival time
#' @param Status alive/dead status. 1 = dead and 0 = alive.
#' @param ep.expression log2CPM expression of exons (samples*exons). This file should contain exon expression of only patients/treated samples and expression of control/normal samples should be removed. Rownames of exon expression should be unique sample IDs that can be mapped to the clinical data.
#' @param ip.expression log2CPM expression of introns (samples*introns). This file should contain intron expression of only patients/treated samples and expression of control/normal samples should be removed. Rownames of intron expression should be unique sample IDs that can be mapped to the clinical data.
#' @param junction.expression log2CPM expression of junctions generated by \code{\link{DEJ}} function (samples*junctions). Before passing this file to survFASE, expression of normal/control samples should be removed, as survFASE requires only treated/patient data. Rownames of junction expression should be unique sample IDs that can be mapped to the clinical data and column names should be unique junction IDs..
#' @param clinical.data clinical data of patients. It should contain survival time (days to last follow up) and survival status (0/1) of the patients. Rownames of clinical data should be unique sample IDs that can be mapped to the expression data.
#' @param rmm readMembershipMatrix matrix of the gene. It contains association between exons and other metafeatures in a gene and is generated by default as RMM.Rdata using \code{\link{readMembershipMatrix}} function.
#' @param imm intronMembershipMatrix matrix of the gene. It contains association between introns and other metafeatures in a gene. It is generated by default as iMM.Rdata using \code{\link{intronMembershipMatrix}} function. iMM is required only for finding survival rate associated with an intron retention event.
#' @param exonID exonID for survival analysis.
#' @param intronID intronID for survival analysis.
#'
#' @import survival
#' @import dplyr
#' @import stats
#'
#' @return survFASE returns an overall p-value, concordance index and Cox-PH statistics. The overall p-value suggests whether or not the given exon/intron significantly affects patient survival. C-index signifies goodness-of-fit of the model. Cox-PH results show which of the metafeatures associated with the exon/intron affect survival rate and their statistical inferences like hazard-ratio, beta-coefficient, etc.
#'
#' @export

survFASE <- function(Time =Time, Status = Status, junction.expression, ep.expression = NULL, ip.expression = NULL, clinical.data, rmm = NULL, imm = NULL, exonID = NULL, intronID = NULL, threshold = 0.60){
  
  metafeatures <- NULL
  if(is.null(intronID) & !is.null(rmm)){
    ## finding associated metafeatures
    #metafeatures <- rmm
    metafeatures <- as.matrix(rmm[ , exonID])
    metafeatures <- subset(metafeatures, metafeatures[,1]>0.0)
  }else if(is.null(exonID) & !is.null(imm)){
    #metafeatures <- imm
    metafeatures <- as.matrix(imm[ , intronID])
    metafeatures <- subset(metafeatures, metafeatures[,1]>0.0)
  }
  
  if(is.null(metafeatures)) base::stop("rmm/imm is empty.")

  #junctions
  junctions <- rownames(metafeatures)[grep('JUNC', rownames(metafeatures))]
  index <- match(junctions, colnames(junction.expression))
  junction.expression <- junction.expression[ , index]
  
  #exons
  exons <- rownames(metafeatures)[grep('EX', rownames(metafeatures))]
  index <- match(exons, colnames(ep.expression))
  ep.expression.temp <- as.matrix(ep.expression[ , index])
  rownames(ep.expression.temp) <- rownames(ep.expression)
  ep.expression <- ep.expression.temp
  if(length(index) == 1) colnames(ep.expression) <- exonID
  
  #introns
  introns <- rownames(metafeatures)[grep('INT', rownames(metafeatures))]
  index <- match(introns, colnames(ip.expression))
  ip.expression.temp <- ip.expression[ , index]
  rownames(ip.expression.temp) <- rownames(ip.expression)
  ip.expression <- ip.expression.temp
  if(length(index) == 1) colnames(ip.expression) <- intronID
  
  # removing metafeatures with expression in less than threshold number of samples
  if(is.null(intronID) & !is.null(rmm)) mf_exp <- cbind(ep.expression, junction.expression) else mf_exp <- cbind(ip.expression, junction.expression)
  mf_exp.temp <- (mf_exp != 0)*1 # making non-zero expression as 1
  threshold <- threshold*nrow(mf_exp.temp) #atleast 51% of samples should have non-zero expression
  counts <- colSums(mf_exp.temp[,]) #checking number of samples with non-zero expression in each mf
  index <- which(counts>threshold) # checking mfs with more than threshold non-zero samples
  if(length(index) == 0) mf_exp <- mf_exp else mf_exp <- mf_exp[ ,index] #removing mfs with less than threshold non-zero expression samples
  
  ## adding clinicaldata to expression
  index <- match(rownames(clinical.data), rownames(mf_exp))
  survival_data <- cbind(clinical.data, mf_exp[index,])
  
  ##cox
  ##running CoxPH
  surv.formula <- Surv(Time, Status) ~ . #creating a survival formula
  surv.formula <- reformulate(colnames(mf_exp), surv.formula[[2]]) # adding mf colnames to survival formula
  surv.result <- coxph(surv.formula, data =  survival_data) #calculating Cox survival
  surv.result.pvalues <- summary(surv.result)$coefficients[,5] #extracting p-values of all mfs
  surv.result.pvalues.sig <- surv.result.pvalues[which(surv.result.pvalues < 0.05)]
  # overall p-value using only significant metafeatures
  overall_pvalue <- .sumPvalsMethod(sum(surv.result.pvalues.sig), length(surv.result.pvalues.sig))
  cindex <- summary(surv.result)$concordance[1] # concordance index
  names(cindex) <- NULL

  survival_result <- list(overall_pvalue = overall_pvalue, concordance_index = cindex, survival_analysis = surv.result)
  
  return(survival_result)
}
